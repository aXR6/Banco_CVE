#!/usr/bin/env python3
# fetch_exploitdb.py

import requests
import csv
import io
import os
from datetime import datetime
from db import (
    insert_exploitdb_metadata,
    insert_exploitdb_shellcodes_metadata,
    insert_exploitdb_raw_exploits,
    insert_exploitdb_raw_shellcodes
)
from config import EXPLOITDB_CSV_URL, SHELLCODES_CSV_URL, EXPLOITDB_REPO_PATH
from embedder import get_embedding

def fetch_exploitdb_exploits():
    """
    1) Baixa o CSV de exploits do Exploit-DB.
    2) Para cada linha, preenche duas listas:
       • meta_exploits: tuplas de 9 campos
         (edb_id, file_path, description, exploit_date, author, platform, type, port, embedding)
       • raw_exploits: tuplas de 10 campos
         (edb_id, file_path, file_content, description, date_posted, author, platform, type, port, embedding)
    3) Chama insert_exploitdb_metadata(...) e insert_exploitdb_raw_exploits(...)
    """

    try:
        resp = requests.get(EXPLOITDB_CSV_URL, timeout=30)
        resp.raise_for_status()
    except requests.RequestException as e:
        print(f"[EDB] Erro ao baixar CSV de exploits: {e}")
        return

    content = resp.content.decode("utf-8", errors="ignore")
    reader = csv.DictReader(io.StringIO(content))

    # Dois dicionários temporários para evitar duplicatas de edb_id
    temp_meta = {}
    temp_raw  = {}

    for row in reader:
        # 1) ID numérico
        try:
            edb_id = int(row["id"])
        except Exception:
            continue

        # 2) Caminho relativo
        file_rel_raw = row.get("file", "").strip()
        if not file_rel_raw:
            continue

        if file_rel_raw.startswith("exploits" + os.sep) or file_rel_raw.startswith("exploits/"):
            rel_path = file_rel_raw
        else:
            rel_path = os.path.join("exploits", file_rel_raw)

        abs_path = os.path.join(EXPLOITDB_REPO_PATH, rel_path)
        if not os.path.isfile(abs_path):
            print(f"[WARN] Arquivo faltando (exploit): {abs_path}")
            file_content = ""
        else:
            # 3) Conteúdo bruto do arquivo, se existir
            try:
                with open(abs_path, "r", errors="ignore") as f:
                    file_content = f.read()
            except Exception as e:
                print(f"[WARN] Não foi possível ler conteúdo de {abs_path}: {e}")
                file_content = ""

        # 4) Outros campos do CSV
        desc     = row.get("description", "").strip()
        date_str = row.get("date", "").strip()
        try:
            exploit_date = datetime.strptime(date_str, "%Y-%m-%d").date()
        except Exception:
            exploit_date = None

        author   = row.get("author", "").strip()
        platform = row.get("platform", "").strip()
        etype    = row.get("type", "").strip()
        port     = row.get("port", "").strip() or None

        # Concatena texto para embedding
        text_for_emb = f"{desc} {author or ''} {platform or ''} {etype or ''} {file_content or ''}"
        emb = get_embedding(text_for_emb)

        # 5) Preenche o dict de metadados (9 campos) se não existir
        if edb_id not in temp_meta:
            temp_meta[edb_id] = (
                edb_id,
                rel_path,
                desc,
                exploit_date,
                author,
                platform,
                etype,
                port,
                emb
            )

        # 6) Preenche o dict de raw (10 campos) se não existir
        if edb_id not in temp_raw:
            temp_raw[edb_id] = (
                edb_id,
                rel_path,
                file_content,
                desc,
                exploit_date,
                author,
                platform,
                etype,
                port,
                emb
            )

    # 7) Converte dicts em listas de tuplas
    records_meta  = list(temp_meta.values())
    records_raw   = list(temp_raw.values())

    # 8) Insere metadados primeiro (ON CONFLICT DO NOTHING)
    if records_meta:
        insert_exploitdb_metadata(records_meta)
    else:
        print("[EDB] Nenhum registro de metadados de exploits encontrado.")

    # 9) Insere raw em seguida (ON CONFLICT DO UPDATE)
    if records_raw:
        insert_exploitdb_raw_exploits(records_raw)
    else:
        print("[EDB] Nenhum registro raw de exploits encontrado.")

def fetch_exploitdb_shellcodes():
    """
    1) Baixa o CSV de shellcodes do Exploit-DB.
    2) Para cada linha, preenche duas listas:
       • meta_shellcodes: tuplas de 9 campos
         (sc_id, file_path, description, date_posted, author, platform, type, language, embedding)
       • raw_shellcodes: tuplas de 10 campos
         (sc_id, file_path, file_content, description, date_posted, author, platform, type, language, embedding)
    3) Chama insert_exploitdb_shellcodes_metadata(...) e insert_exploitdb_raw_shellcodes(...)
    """

    try:
        resp = requests.get(SHELLCODES_CSV_URL, timeout=30)
        resp.raise_for_status()
    except requests.RequestException as e:
        print(f"[EDB] Erro ao baixar CSV de shellcodes: {e}")
        return

    content = resp.content.decode("utf-8", errors="ignore")
    reader = csv.DictReader(io.StringIO(content))

    temp_meta = {}
    temp_raw  = {}

    for row in reader:
        # 1) ID numérico
        try:
            sc_id = int(row["id"])
        except Exception:
            continue

        # 2) Caminho relativo
        file_rel_raw = row.get("file", "").strip()
        if not file_rel_raw:
            continue

        if file_rel_raw.startswith("shellcodes" + os.sep) or file_rel_raw.startswith("shellcodes/"):
            rel_path = file_rel_raw
        else:
            rel_path = os.path.join("shellcodes", file_rel_raw)

        abs_path = os.path.join(EXPLOITDB_REPO_PATH, rel_path)
        if not os.path.isfile(abs_path):
            print(f"[WARN] Arquivo faltando (shellcode): {abs_path}")
            file_content = ""
        else:
            # 3) Conteúdo bruto
            try:
                with open(abs_path, "r", errors="ignore") as f:
                    file_content = f.read()
            except Exception as e:
                print(f"[WARN] Não foi possível ler conteúdo de {abs_path}: {e}")
                file_content = ""

        # 4) Outros campos do CSV
        desc     = row.get("description", "").strip()
        date_str = row.get("date", "").strip()
        try:
            post_date = datetime.strptime(date_str, "%Y-%m-%d").date()
        except Exception:
            post_date = None

        author   = row.get("author", "").strip()
        platform = row.get("platform", "").strip()
        type_sc  = row.get("type", "").strip()
        language = row.get("language", "").strip()

        # Concatena texto para embedding
        text_for_emb = f"{desc} {author or ''} {platform or ''} {type_sc or ''} {file_content or ''}"
        emb = get_embedding(text_for_emb)

        # 5) Preenche dict de metadados (9 campos) se não existir
        if sc_id not in temp_meta:
            temp_meta[sc_id] = (
                sc_id,
                rel_path,
                desc,
                post_date,
                author,
                platform,
                type_sc,
                language,
                emb
            )

        # 6) Preenche dict de raw (10 campos) se não existir
        if sc_id not in temp_raw:
            temp_raw[sc_id] = (
                sc_id,
                rel_path,
                file_content,
                desc,
                post_date,
                author,
                platform,
                type_sc,
                language,
                emb
            )

    records_meta   = list(temp_meta.values())
    records_raw    = list(temp_raw.values())

    # 7) Insere metadados (ON CONFLICT DO NOTHING)
    if records_meta:
        insert_exploitdb_shellcodes_metadata(records_meta)
    else:
        print("[EDB] Nenhum registro de metadados de shellcodes encontrado.")

    # 8) Insere raw (ON CONFLICT DO UPDATE)
    if records_raw:
        insert_exploitdb_raw_shellcodes(records_raw)
    else:
        print("[EDB] Nenhum registro raw de shellcodes encontrado.")
